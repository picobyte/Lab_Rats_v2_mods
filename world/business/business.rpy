init -23 python:
    class Division(renpy.store.object):
        def __init__(self, name="Freelancer", people=None, room=None, jobs=None):
            self.name = name
            self.people = set(people or []) # may be away, test room.people for non-absensent
            self.jobs = set(jobs or [name])
            self.room = getattr(world, room)
            self.serum = None
            self.uniform = None

        def give_daily_serum(self, inventory):
            if self.serum:
                for person in self.room.people:
                    if inventory.get_serum_count(self.serum) > 0:
                        inventory.change_serum(self.serum,-1)
                        person.give_serum(copy.copy(self.serum)) #use a copy rather than the main class, so we can modify and delete the effects without changing anything else.
                    else:
                        return "Stockpile ran out of %s to give to the %s division." % (self.serum.name, self.name.lower())

    class Business(renpy.store.object):
        def __init__(self, name, division):
            self.name = name
            self.division = set(division)

    class MyCorp(Business):
        # main jobs to start with:
        # 1) buying raw supplies.
        # 2) researching new serums.
        # 2a) The player (only) designs new serums to be researched.
        # 3) working in the lab to produce serums.
        # 4) Working in marketing. Increases volumn you can sell, and max price you can sell for.
        # 5) Packaging and selling serums that have been produced.
        # 6) General secretary work. Starts at none needed, grows as your company does (requires an "HR", eventually). Maybe a general % effectivness rating.
        def __init__(self):
            # m_div etc: The phsyical locations of all of the teams, so you can move to different offices in the future.
            name = persistent.company_name

            # Increases company marketability. Raises max price serum can be sold for, and max volumn that can be sold.
            self.m_div = Division("Marketing", [], "m_room")

            # Physically makes the serum and sends it off to be sold.
            self.p_div = Division("Production", [], "p_room")

            # Researches new serums that the player designs, does theoretical research into future designs, or improves old serums slightly over time
            self.r_div = Division("Research and Development", [], "rd_room", ["Researcher"])

            # Buys the raw supplies used by the other departments.
            self.s_div = Division("Supply Procurement", [], "office", ["Supply"])

            # Manages everyone else and improves effectiveness. Needed as company grows.
            self.h_div = Division("Human Resources", [], "office")
            super(MyCorp, self).__init__(name, [self.m_div, self.p_div, self.r_div, self.s_div, self.h_div])

            self.funds = 1000 #Your starting wealth.

            self.bankrupt_days = 0 #How many world.days you've been bankrupt. If it hits the max value you lose.
            self.max_bankrupt_days = 3 #How many world.days you can be negative without loosing the game. Can be increased through research.

            self.supply_count = 0
            self.supply_goal = 250
            self.auto_sell_threshold = None
            self.marketability = 0
            self.production_points = 0
            self.team_effectiveness = 100 #Ranges from 50 (Chaotic, everyone functions at 50% speed) to 200 (masterfully organized). Normal levels are 100, special traits needed to raise it higher.
            self.effectiveness_cap = 100 #Max cap, can be raised.

            self.serum_traits = default_serum_traits
            self.serum_designs = []
            self.active_research_design = None #

            self.serum_production_target = None
            self.inventory = SerumInventory([])
            self.sale_inventory = SerumInventory([])

            self.active_policies = set()

            self.message_list = {} # This dict stores unique and counts message. If 0 it is shown once without a count at the end of the world.day.
            self.production_potential = 0 #How many production points the team was capable of
            self.supplies_purchased = 0
            self.production_used = 0 #How many production points were actually used to make something.
            self.research_produced = 0 #How much research the team produced today.
            self.sales_made = 0

            self.mandatory_crises_list = [] #A list of crises to be resolved at the end of the turn, generally generated by events that have taken place.
            self.clear_messages()

        def run_turn(self): #Run each time the time segment changes. Most changes are done here.

            #Compute efficency drop
            for div in self.division:
                for person in div.room.people: #Only people in the office lower effectiveness, no loss on weekends, not in for the world.day, etc.
                    if person.job in div.jobs:
                        self.team_effectiveness += -1 #TODO: Make this dependant on charisma (High charisma have a lower impact on effectiveness) and happiness.

            #Compute effiency rise from HR
            for person in self.h_div.room.people:
                if person.job in self.h_div.jobs:
                    self.hr_progress(person.charisma,person.int,person.hr_skill)

            if self.team_effectiveness < 50:
                self.team_effectiveness = 50

            if self.team_effectiveness > self.effectiveness_cap:
                self.team_effectiveness = self.effectiveness_cap

            #Compute other deparement effects
            for person in self.s_div.room.people: #Check to see if the person is in the room, otherwise don't count their progress (they are at home, dragged away by PC, weekend, etc.)
                if person.job in self.s_div.jobs:
                    self.supply_purchase(person.focus,person.charisma,person.supply_skill)

            for person in self.r_div.room.people:
                if person.job in self.r_div.jobs:
                    self.research_progress(person.int,person.focus,person.research_skill)

            for person in self.p_div.room.people:
                if person.job in self.p_div.jobs:
                    self.production_progress(person.focus,person.int,person.production_skill)

            for person in self.m_div.room.people:
                if person.job in self.m_div.jobs:
                    self.sale_progress(person.charisma,person.focus,person.market_skill)

        def run_day(self): #Run at the end of the world.day.
            #Pay everyone for the world.day
            cost = self.calculate_salary_cost()
            self.funds += -cost

            return

        def is_open_for_business(self): #Checks to see if employees are currently working
            if world.time_of_day == 1 or world.time_of_day == 2 or world.time_of_day == 3: #TODO: give people the weekends off.
                return True
            else:
                return False

        def get_uniform(self, job): #Takes a division (a room) and returns the correct uniform for that division, if one exists. If it is None, returns false.
            for div in self.division:
                if job in div.jobs:
                    return div.uniform

        def clear_messages(self): #clear all messages for the world.day.
            self.message_list = {} # This dict stores unique and counts message. If 0 it is shown once without a count at the end of the world.day.
            self.production_potential = 0 #How many production points the team was capable of
            self.supplies_purchased = 0
            self.production_used = 0 #How many production points were actually used to make something.
            self.research_produced = 0 #How much research the team produced today.
            self.sales_made = 0

        def calculate_salary_cost(self):
            daily_cost = 0
            for person in self.get_employee_list():
                daily_cost += person.salary
            return daily_cost

        def add_serum_design(self,serum):
            while not "name" in serum:
                name = renpy.input("Please give this serum design a name.")
                if not name or name in self.serum_designs:
                    renpy.say("", "That name is already registered. Please use another.")
                else:
                    serum["name"] = name
            self.serum_designs.append(serum)

        def set_serum_research(self,name):
            self.active_research_design = name

        def is_reasearching_drug(self):
            return self.active_research_design and "value" in self.active_research_design

        def research_progress(self,int,focus,skill):
            research_amount = __builtin__.round(((3*int) + focus + (2*skill) + 10) * self.team_effectiveness)/100
            self.research_produced += research_amount
            if self.active_research_design:
                design = self.active_research_design
                design["research done"] += research_amount

                if design["research done"] >= design["research required"]: #Returns true if the research is completed by this amount'
                    if "value" in design: # its a drug
                        self.mandatory_crises_list.append(Action("Research Finished Crisis",serum_creation_crisis_requirement,"serum_creation_crisis_label",design)) #Create a serum finished crisis, it will trigger at the end of the round
                    self.message_list["Finished researching: %s" % design["name"]] = 0
                    self.active_research_design = None

        def player_research(self):
            self.research_progress(world.mc.int,world.mc.focus,world.mc.research_skill)

        def player_buy_supplies(self):
            self.supply_purchase(world.mc.focus,world.mc.charisma,world.mc.supply_skill)

        def supply_purchase(self,focus,cha,skill):
            max_supply = __builtin__.round(((3*focus) + (cha) + (2*skill) + 10) * (self.team_effectiveness))/100
            if max_supply + self.supply_count > self.supply_goal:
                max_supply = self.supply_goal - self.supply_count
                if max_supply <= 0:
                    return

            self.funds += -max_supply
            self.supply_count += max_supply
            self.supplies_purchased += max_supply #Used for end of world.day reporting

        def player_market(self):
            self.sale_progress(world.mc.charisma,world.mc.focus,world.mc.market_skill)

        def sale_progress(self,cha,focus,skill):

            serum_value_multiplier = 1.00 #For use with value boosting policies. Multipliers are multiplicative.
            if world.mc.business.m_div.uniform and "Male Focused Modeling" in world.mc.business.active_policies:
                #If there is a uniform and we have the policy to increase value based on that we change the multilier.
                sluttiness_multiplier = (world.mc.business.m_div.uniform.slut_requirement/100.0) + 1
                serum_value_multiplier = serum_value_multiplier * (sluttiness_multiplier)

            serum_sale_count = __builtin__.round(((3*cha) + (focus) + (2*skill) + 10) * (self.team_effectiveness))/100 #Total number of doses of serum that can be sold by this person.
            sorted_by_value = sorted(self.sale_inventory.serums_held, key = lambda serum: serum[0].value) #List of tuples [SerumDesign, count], sorted by the value of each design. Used so most valuable serums are sold first.
            if self.sale_inventory.get_any_serum_count() < serum_sale_count:
                serum_sale_count = self.sale_inventory.get_any_serum_count()

            if serum_sale_count > 0: #ie. we have serum in our inventory to sell, and the capability to sell them.
                for serum in sorted_by_value:
                    if serum_sale_count <= serum[1]:
                        #There are enough to satisfy order. Remove, add value to wallet, and break
                        value_sold = serum_sale_count * serum[0].value * serum_value_multiplier
                        self.funds += value_sold
                        self.sales_made += value_sold
                        self.sale_inventory.change_serum(serum[0],-serum_sale_count)
                        serum_sale_count = 0
                        break
                    #There are not enough in this single order, remove _all_ of them, add value, go onto next thing.
                    serum_sale_count += -serum[1] #We were able to sell this number of serum.
                    value_sold = serum[1] * serum[0].value * serum_value_multiplier
                    self.funds += value_sold
                    self.sales_made += value_sold
                    self.sale_inventory.change_serum(serum[0],-serum[1]) #Should set serum count to 0.
                    #Don't break, we haven't used up all of the serum count


        def production_progress(self,focus,int,skill):
            production_amount = __builtin__.round(((3*focus) + (int) + (2*skill) + 10) * (self.team_effectiveness))/100
            self.production_potential += production_amount
            if production_amount > self.supply_count:
                production_amount = self.supply_count
            self.production_used += production_amount

            if self.serum_production_target != None:
                self.supply_count += -production_amount
                ##Check how many serum can be made, make them and add them to your inventory.
                self.production_points += production_amount
                serum_count = self.production_points//self.serum_production_target.production_cost
                if serum_count > 0:
                    msg = "Produced " + self.serum_production_target.name
                    self.message_list[msg] = self.message_list[msg] + serum_count if msg in self.message_list else serum_count
                    self.production_points += -(serum_count * self.serum_production_target.production_cost)
                    if self.serum_production_target is not None and self.auto_sell_threshold is not None and self.inventory.get_serum_count(self.serum_production_target)+serum_count > self.auto_sell_threshold: #If there is a limit set, and the production takes us above the limit, sell extra
                        the_difference = (self.inventory.get_serum_count(self.serum_production_target) + serum_count) - self.auto_sell_threshold #Get the count of serum we can still add to the business inventory. ie set us to the limit.
                        self.inventory.change_serum(self.serum_production_target,serum_count-the_difference)
                        self.sale_inventory.change_serum(self.serum_production_target,the_difference)
                    else:
                        self.inventory.change_serum(self.serum_production_target,serum_count)

        def change_production(self,new_serum):
            self.serum_production_target = new_serum
            self.auto_sell_threshold = None
            self.production_points = 0

        def player_production(self):
            self.production_progress(world.mc.focus,world.mc.int,world.mc.production_skill)

        def player_hr(self):
            self.hr_progress(world.mc.charisma,world.mc.int,world.mc.hr_skill)

        def hr_progress(self,cha,int,skill): #Don't compute efficency cap here so that player HR effort will be applied against any efficency drop even though it's run before the rest of the end of the turn.
            self.team_effectiveness += (3*cha) + (int) + (2*skill) + 10

        def add_employee(self, new_person, division, job=None, to_room_as_well=True):
            division.people.add(new_person)
            new_person.job = job or renpy.random.sample(division.jobs, 1)[0]
            if to_room_as_well:
                division.room.people.add(new_person)

        def remove_employee(self, the_person):
            for div in self.division:
                if the_person in div.people:
                    div.people.remove(the_person)
                    if the_person in div.room.people:
                        div.room.people.remove(the_person)
                    break
        def is_employee(self, person):
            return any(person in div.people for div in self.division)

        def get_employee_list(self):
            return [people for div in self.division for people in div.people]

        def get_employee_count(self):
            return sum(len(div.people) for div in self.division)

        def get_max_employee_slut(self):
            maximum = -1 #Set to -1 for an empty business, all calls should require at least sluttiness 0
            for person in self.get_employee_list():
                if person.sluttiness > maximum:
                    maximum = person.sluttiness
            return maximum

        def get_employee_title(self, the_person):
            for div in self.division:
                if the_person in div.people:
                    return the_person.job
            return "None"

        def give_daily_serum(self):
            for div in self.division:
                the_message = div.give_daily_serum(self.inventory)
                if the_message:
                    self.message_list[the_message] = 0

        def purchase_policy(self, policy):
            self.funds -= policy.cost
            self.active_policies.add(policy)

        def get_max_outfits_to_change(self):
            return max(map(lambda n: policies[n].get("max_outfits_to_change", 0), self.active_policies))


